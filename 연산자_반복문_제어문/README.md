- 산술 연산자

  | +    | 왼쪽의 피연산자에 오른쪽의 피연산자를 더함.                  |
  | ---- | ------------------------------------------------------------ |
  | -    | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌.                  |
  | *    | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱함.                  |
  | /    | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눔.                  |
  | %    | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함. |

- 비트 연산자

  | &    | 대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)       |
  | ---- | ------------------------------------------------------------ |
  | \|   | 대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산) |
  | ^    | 대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)      |
  | ~    | 비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산, 1의 보수) |
  | <<   | 명시된 수만큼 비트들을 전부 왼쪽으로 이동시킴. (left shift 연산) |
  | >>   | 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산) |
  | >>>  | 지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨. |

- 관계 연산자

  | ==   | 왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 참을 반환함.    |
  | ---- | ------------------------------------------------------------ |
  | !=   | 왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 참을 반환함. |
  | >    | 왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 참을 반환함.    |
  | >=   | 왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 참을 반환함. |
  | <    | 왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 참을 반환함.  |
  | <=   | 왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 참을 반환함. |

- 논리 연산자

  | &&   | 논리식이 모두 참이면 참을 반환함. (논리 AND 연산)            |
  | ---- | ------------------------------------------------------------ |
  | \|\| | 논리식 중에서 하나라도 참이면 참을 반환함. (논리 OR 연산)    |
  | !    | 논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함. (논리 NOT 연산) |

- instanceof

  instanceof 연산자는 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 반환해 줍니다. instanceof 연산자는 왼쪽 피연산자인 인스턴스가 오른쪽 피연산자인 클래스나 인터페이스로부터 생성되었으면 true를 반환하고, 그렇지 않으면 false를 반환합니다.

  > 인스턴스이름 **instanceof** 클래스또는인터페이스이름

- assignment(=) operator

  | =    | 왼쪽의 피연산자에 오른쪽의 피연산자를 대입함.                |
  | ---- | ------------------------------------------------------------ |
  | +=   | 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
  | -=   | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
  | *=   | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
  | /=   | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
  | %=   | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함. |
  | &=   | 왼쪽의 피연산자를 오른쪽의 피연산자와 비트 AND 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
  | \|=  | 왼쪽의 피연산자를 오른쪽의 피연산자와 비트 OR 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
  | ^=   | 왼쪽의 피연산자를 오른쪽의 피연산자와 비트 XOR 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
  | <<=  | 왼쪽의 피연산자를 오른쪽의 피연산자만큼 왼쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
  | >>=  | 왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호를 유지하며 오른쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
  | >>>= | 왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호에 상관없이 오른쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |

- 화살표(->) 연산자

  ##### 메소드

  int min(int x, int y) {

    return x < y ? x : y;

  }

  ##### 람다 표현식

  (x, y) -> x < y ? x : y;

   자바에서는 클래스의 선언과 동시에 객체를 생성하므로, 단 하나의 객체만을 생성할 수 있는 클래스를 익명 클래스라고 합니다.

  따라서 자바에서 람다 표현식은 익명 클래스와 같다고 할 수 있습니다.

  자바에서는 화살표(->) 기호를 사용하여 람다 표현식을 작성할 수 있습니다.

  ##### 문법

  (매개변수목록) -> { 함수몸체 }

  자바에서 람다 표현식을 작성할 때 유의해야 할 사항은 다음과 같습니다.

   

  1. 매개변수의 타입을 추론할 수 있는 경우에는 타입을 생략할 수 있습니다.

  2. 매개변수가 하나인 경우에는 괄호(())를 생략할 수 있습니다.

  3. 함수의 몸체가 하나의 명령문만으로 이루어진 경우에는 중괄호({})를 생략할 수 있습니다. (이때 세미콜론(;)은 붙이지 않음)

  4. 함수의 몸체가 하나의 return 문으로만 이루어진 경우에는 중괄호({})를 생략할 수 없습니다.

  5. return 문 대신 표현식을 사용할 수 있으며, 이때 반환값은 표현식의 결괏값이 됩니다. (이때 세미콜론(;)은 붙이지 않음)

- 3항 연산자

  > 조건식 **?** 반환값1 **:** 반환값2

- 연산자 우선 순위

  | 우선순위 |   연산자   |                             설명                             |      결합 방향      |
  | :------: | :--------: | :----------------------------------------------------------: | :-----------------: |
  |  **1**   |     []     |                         첨자 연산자                          | 왼쪽에서 오른쪽으로 |
  |          |     .      |                         멤버 연산자                          | 왼쪽에서 오른쪽으로 |
  |  **2**   |     ++     |                       후위 증가 연산자                       | 왼쪽에서 오른쪽으로 |
  |          |     --     |                       후위 감소 연산자                       | 왼쪽에서 오른쪽으로 |
  |  **3**   |     !      |                       논리 NOT 연산자                        | 오른쪽에서 왼쪽으로 |
  |          |     ~      |                       비트 NOT 연산자                        | 오른쪽에서 왼쪽으로 |
  |          |     +      |                   양의 부호 (단항 연산자)                    | 오른쪽에서 왼쪽으로 |
  |          |     -      |                   음의 부호 (단항 연산자)                    | 오른쪽에서 왼쪽으로 |
  |          |     ++     |                       전위 증가 연산자                       | 오른쪽에서 왼쪽으로 |
  |          |     --     |                       전위 감소 연산자                       | 오른쪽에서 왼쪽으로 |
  |          |   (타입)   |                      타입 캐스트 연산자                      | 오른쪽에서 왼쪽으로 |
  |  **4**   |     *      |                         곱셈 연산자                          | 왼쪽에서 오른쪽으로 |
  |          |     /      |                        나눗셈 연산자                         | 왼쪽에서 오른쪽으로 |
  |          |     %      |                        나머지 연산자                         | 왼쪽에서 오른쪽으로 |
  |  **5**   |     +      |                  덧셈 연산자 (이항 연산자)                   | 왼쪽에서 오른쪽으로 |
  |          |     -      |                  뺄셈 연산자 (이항 연산자)                   | 왼쪽에서 오른쪽으로 |
  |  **6**   |     <<     |                   비트 왼쪽 시프트 연산자                    | 왼쪽에서 오른쪽으로 |
  |          |     >>     |          부호 비트를 확장하면서 비트 오른쪽 시프트           | 왼쪽에서 오른쪽으로 |
  |          |    >>>     |            부호 비트까지 모두 비트 오른쪽 시프트             | 왼쪽에서 오른쪽으로 |
  |  **7**   |     <      |                    관계 연산자(보다 작은)                    | 왼쪽에서 오른쪽으로 |
  |          |     <=     |                관계 연산자(보다 작거나 같은)                 | 왼쪽에서 오른쪽으로 |
  |          |     >      |                     관계 연산자(보다 큰)                     | 왼쪽에서 오른쪽으로 |
  |          |     >=     |                관계 연산자(보다 크거나 같은)                 | 왼쪽에서 오른쪽으로 |
  |          | instanceof |                  인스턴스의 실제 타입 반환                   | 왼쪽에서 오른쪽으로 |
  |  **8**   |     ==     |                     관계 연산자(와 같은)                     | 왼쪽에서 오른쪽으로 |
  |          |     !=     |                  관계 연산자(와 같지 않은)                   | 왼쪽에서 오른쪽으로 |
  |  **9**   |     &      |                       비트 AND 연산자                        | 왼쪽에서 오른쪽으로 |
  |  **10**  |     ^      |                       비트 XOR 연산자                        | 왼쪽에서 오른쪽으로 |
  |  **11**  |     \|     |                        비트 OR 연산자                        | 왼쪽에서 오른쪽으로 |
  |  **12**  |     &&     |                       논리 AND 연산자                        | 왼쪽에서 오른쪽으로 |
  |  **13**  |    \|\|    |                        논리 OR 연산자                        | 왼쪽에서 오른쪽으로 |
  |  **14**  |    ? :     |                       삼항 조건 연산자                       | 오른쪽에서 왼쪽으로 |
  |  **15**  |     =      | 대입 연산자 및 복합 대입 연산자(=, +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, ^=, \|=) | 오른쪽에서 왼쪽으로 |

- (optional) Java 13. switch 연산자

  switch 문의 조건 값으로는 int형으로 승격할 수 있는(integer promotion) 값만이 사용될 수 있습니다.

  즉, 자바에서는 swich 문의 조건 값으로 byte형, short형, char형, int형의 변수나 리터럴을 사용할 수 있습니다.

  또한, 이러한 기본 타입에 해당하는 데이터를 객체로 포장해 주는 래퍼 클래스(Wrapper class) 중에서 위에 해당하는 Byte, Short, Character, Integer 클래스의 객체도 사용할 수 있습니다.

  그리고 enum 키워드를 사용한 열거체(enumeration type)와 String 클래스의 객체도 사용할 수 있습니다.

  **switch** (조건 값) {

    **case** 값1 **:**

  ​    조건 값이 값1일 때 실행하고자 하는 명령문;

  ​    **break**;

    **case** 값2 **:**

  ​    조건 값이 값2일 때 실행하고자 하는 명령문;

  ​    **break**;

    ...

    **default:**

  ​    조건 값이 어떠한 **case** 절에도 해당하지 않을 때 실행하고자 하는 명령문;

  ​    **break**;

  }

  12와 13에서 추가된 것

  

- 선택문

  **if** (조건식1) {

    조건식1의 결과가 참일 때 실행하고자 하는 명령문;

  } **else** **if** (조건식2) {

    조건식2의 결과가 참일 때 실행하고자 하는 명령문;

  } **else** {

    조건식1의 결과도 거짓이고, 조건식2의 결과도 거짓일 때 실행하고자 하는 명령문;

  }

- 반복문

  - while

    초기식;

    **while** (조건식) {

      조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;

      조건식의 결과를 변경하는 명령문

    }

  우선 참인지 판단하고 참인 경우 내부의 명령문들을 실행합니다.

  - do-while

    **do** {

      조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;

    } **while** (조건식);

  - for

    **for** (초기식; 조건식; 증감식) {

      조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;

    }

  - Enhanced for

     **for** (타입 변수이름 **:** 배열이나컬렉션이름) {

      배열의 길이만큼 반복적으로 실행하고자 하는 명령문;

    }
