# 프리미티브 타입 종류와 값의 범위 그리고 기본 값



| Type       | 가지는 값        | Size   | default | 범위                                       |
| ---------- | ---------------- | ------ | ------- | ------------------------------------------ |
| boolean    | true / false     | 1bit   | false   | NA(범위가 없다.)                           |
| char       | Unicode 문자     | 16bits | \u0000  | \u0000 ~ \uFFFF                            |
| byte       | 부호가 있는 정수 | 8bits  | 0       | –128 ~ 127                                 |
| short      | 부호가 있는 정수 | 16bits | 0       | –32768 ~ 32767                             |
| **int**    | 부호가 있는 정수 | 32bits | 0       | –2147483648 ~ 2147483647                   |
| long       | 부호가 있는 정수 | 64bits | 0       | –9223372036854775808 ~ 9223372036854775807 |
| float      | 실수             | 32bits | 0.0     | ±1.4E–45 ~ ±3.4028235E+38                  |
| **double** | 실수             | 64bits | 0.0     | ±4.9E–324 to ±1.7976931348623157E+308      |

굵은 글씨로 표현된 int와 double은 각각 정수형의 기본값, 실수형의 기본값입니다.

# 프리미티브 타입과 레퍼런스 타입

위에서 소개한 프리미티브 타입를 제외한 자바에서 변수선언 시 지정하는 모든 타입은 레퍼런스 타입입니다.

자바에서는 8개의 primitive type들과 함께 클래스, 인터페이스 그리고 배열 타입을 정의하고 있습니다. 

primitive type이 아닌 모든 타입은 non-primitive type 또는 reference type이라고 합니다.

# 리터럴

소스 코드의 고정된 값을 대표하는 용어입니다.

리터럴은 정수, 실수, 문자 리터럴이 있습니다.

1. 정수

   | 10진수 | 2진수     | 8진수    | 16진수    |
   | ------ | --------- | -------- | --------- |
   | 아무것도 붙이지않음 | 0b로 시작 | 0로 시작 | 0x로 시작 |

   정수 리터럴은 int형으로 컴파일이되며, long 타입의 리터럴은 숫자 뒤에 L또는 l을 붙여서 타입을 명시해줍니다.

2. 실수

   실수 타입의 리터럴은 double 타입으로 컴파일이 됩니다.

   float 형의 경우에는 f 또는 F를 붙여줘야하고, double형의 경우에는 d(D)를 생략할 수 있습니다.

3. 문자

   | 특수문자             | 리터럴                           |
   | -------------------- | -------------------------------- |
   | tab                  | \t                               |
   | backspace            | \b                               |
   | form feed            | \f                               |
   | new line             | \n                               |
   | carriage return      | \r                               |
   | \                    | \ \                              |
   | '(작은 따옴표)       | \ '                              |
   | "(큰 따옴표)         | \ "                              |
   | 유니코드(16진수)문자 | \u유니코드(ex char a = '\u0000') |

# 변수 선언 및 초기화하는 방법

```java
[접근제어자(생략시 default)] [static] [final]변수타입 변수이름 = 초기화 하고싶은 값;
ex)
//instance 변수
int number = 100;
//static 변수(클래스 변수)
static int number = 100;
//레퍼런스 타입도 같은 방식으로 가능하다.
public static int[ ] numbers;
//상수(final을 붙여준다.)
private static final String mappedUrl = "localhost:8080/login"
```



# 변수의 스코프와 라이프타임

### 변수의 스코프

변수의 스코프란 scope라는 단어에서 알 수 있듯 변수가 볼 수 있는 범위를 의미합니다.

| 클래스 변수 | 로컬 변수        | 인스턴스 변수                            |
| ----------- | ---------------- | ---------------------------------------- |
| 클래스 전체 | 선언된 블록 내부 | 클래스 중 static 메소드를 제외한 모든 곳 |

다음 코드에서 로컬 변수의 예시를 확인해보겠습니다.

```java
public class Ex{
  static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  public static void main(String[] args){
    int i = 10;
    for(int j = 0;j<i;j++){
      int k = 0;
      k = i+j;
    }//block1
  }//block2
}//block3
```

block 1에서 선언된 j와 k를 block 2와 3에서 접근하려고 하면 에러가 발생합니다.<br>
block 2에서 선언된 i는 block 1에서는 접근할 수 있지만, block3에서는 접근할 수 없습니다.<br>
block 3에서 선언된 br은 block 1,2,3 모두에서 접근할 수 있습니다.

### 변수의 lifetime

1. 클래스 변수

   클래스가 메모리에 로딩되어 있다면 클래스 변수는 유지됩니다.

2. 로컬 변수
   로컬 변수의 scope에 해당하는 블록이 끝날 때까지 로컬 변수는 유지됩니다.

3. 인스턴스 변수
   해당 객체가 gc에 의해 해제되기 전까지, 즉, 메모리에 남아있는 동안 인스턴스 변수는 유지됩니다.

# 타입 변환, 캐스팅 그리고 타입 프로모션

타입변환은 데이터의 타입을 바꿔주는 것을 의미합니다. 타입변환에는 캐스팅과 프로모션이 있습니다.

### 캐스팅

캐스팅은 Primitive 타입과 Reference 타입의 방식이 다릅니다.

1. Primitive Type

   Casting은 명시적 형변환으로 메모리의 크기가 큰 데이터 타입에서 작은 데이터 타입으로 타입 변환을 할 때 **반드시** 해야합니다. 캐스팅을 하지않으면 에러가 발생합니다.

2. Reference Type

   레퍼런스 타입은 상속관계에 있는 객체들 사이에서만 캐스팅이 가능합니다.
   부모 클래스는 타입 캐스팅 없이 자식 객체를 대입할 수 있고(Up Casting)

   자식 클래스는 캐스팅을 해줘야지만 부모 객체를 대입할 수 있습니다.(Down Casting)

   그 이유는 자식 클래스가 가지고 있는 메모리의 크기가 부모 클래스보다 크기 때문에, 별도의 명시없이 자식 클래스에 부모 객체를 대입하면, 있어야할게 없는 상황이기 때문에 에러가 발생합니다.

   이와 같은 이유로 부모 클래스의 객체를 생성하면서, 자식 클래스의 객체로 캐스팅을 하면 에러가 발생합니다.

### 프로모션

작은 데이터 타입에서 큰 데이터 타입으로 바꿔주는 것으로 별도의 캐스팅 없이 자동으로 바꿀 수 있습니다.

레퍼런스 타입의 프로모션은 캐스팅과 마찬가지로 상속관계에서만 가능합니다.

# 1차 및 2차 배열 선언하기

배열은 레퍼런스 타입으로 자바에서 제공하는 모든 데이터 타입으로 만들 수 있습니다.

한 번 선언하면 크기가 고정적이라는 특징이 있고, 같은 데이터 타입들을 모아놓은 동형집합으로 데이터 관리를 하는데 용이합니다.

배열은 참조변수로 관리하며, 2차원 배열은 1차원 배열에 다른 1차원 배열의 참조변수를 저장해놓은 상태입니다.

### 1차원

데이터타입[ ] 변수명 = new 데이터타입[크기];

데이터타입[ ] 변수명 = new 데이터타입[ ]{초기화할 배열};

데이터타입 변수명[ ] = new 데이터타입[크기];

데이터타입 변수명[ ] = new 데이터타입[ ]{초기화할 배열};

### 2차원

1. 데이터타입[ ] [ ] 변수명 = new 데이터타입[크기] [크기];

2. 데이터타입[ ] [ ] 변수명 = new 데이터타입[크기] [ ];

# 타입 추론, var

타입 추론은 변수의 타입을 이전에 명시하지않고 컴파일러가 추측하게해서 컴파일 하는 방식입니다.

var는 초기화값이 있는 지역변수로만 선언이 가능하고, 멤버변수, 메서드의 파라미터, 리턴 타입으로는 사용이 불가능합니다.
